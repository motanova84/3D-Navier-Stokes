#!/usr/bin/env python3
"""
Seeley-DeWitt Tensor Φ_ij(Ψ) for Extended Navier-Stokes
========================================================

Implements the tensor Φ_ij(Ψ) derived from the Seeley-DeWitt expansion
that provides quantum-geometric coupling to the Navier-Stokes equations.

Theory:
-------
The Seeley-DeWitt expansion provides heat kernel coefficients (a₁, a₂, a₃)
that encode the geometric structure of the quantum field coupling.

The tensor Φ_ij(Ψ) includes:
1. Second spatial derivatives: Ψ·∂²ε/∂x_i∂x_j + log(μ⁸/m_Ψ⁸)·∂²Ψ/∂x_i∂x_j
2. Time derivatives: 2·∂²Ψ/∂t²
3. Effective Ricci tensor: R_ij ≈ ∂_i∂_j ε (generated by fluid)
4. 3D projection for fluid dynamics

Extended Navier-Stokes Equation:
--------------------------------
∂_t u_i + u_j∇_j u_i = -∇_i p + ν∆u_i + Φ_ij(Ψ)u_j

This formulation couples quantum coherence (Ψ field) with classical fluid dynamics,
providing geometric regularization that prevents singularities.
"""

import numpy as np
from typing import Tuple, Dict, Optional, Callable
from dataclasses import dataclass


@dataclass
class SeeleyDeWittParams:
    """Parameters for Seeley-DeWitt tensor computation"""
    # Quantum field parameters
    mu: float = 1.0  # Energy scale (characteristic scale)
    m_psi: float = 1.0  # Noetic field mass scale
    
    # Noetic field parameters
    I: float = 1.0  # Information density
    A_eff: float = 1.0  # Effective amplitude
    f0: float = 141.7001  # Universal coherence frequency (Hz)
    c0: float = 1.0  # Phase gradient constant
    
    # Regularization parameters
    epsilon_0: float = 1e-3  # Base regularization parameter
    lambda_scale: float = 1.0  # Dual-limit scaling parameter
    alpha: float = 1.5  # Scaling exponent (α > 1)
    
    def compute_psi_amplitude(self) -> float:
        """Compute noetic field amplitude: Ψ₀ = I × A²_eff"""
        return self.I * self.A_eff**2
    
    def compute_omega0(self) -> float:
        """Compute angular frequency: ω₀ = 2πf₀"""
        return 2 * np.pi * self.f0
    
    def compute_log_ratio(self) -> float:
        """Compute logarithmic ratio: log(μ⁸/m_Ψ⁸)"""
        return 8 * np.log(self.mu / self.m_psi)
    
    def compute_epsilon(self) -> float:
        """Compute dual-limit regularization: ε = λf₀^(-α)"""
        return self.lambda_scale * self.f0**(-self.alpha)


class SeeleyDeWittTensor:
    """
    Implements the Seeley-DeWitt tensor Φ_ij(Ψ) for quantum-geometric
    coupling in extended Navier-Stokes equations.
    
    The tensor provides:
    1. Geometric regularization through Ricci-like terms
    2. Quantum coherence coupling via Ψ field
    3. Singularity prevention through non-local interactions
    4. Energy-momentum balance via Seeley-DeWitt coefficients
    """
    
    def __init__(self, params: Optional[SeeleyDeWittParams] = None):
        """
        Initialize Seeley-DeWitt tensor computation.
        
        Args:
            params: Seeley-DeWitt parameters (uses defaults if None)
        """
        self.params = params or SeeleyDeWittParams()
        self.psi_0 = self.params.compute_psi_amplitude()
        self.omega_0 = self.params.compute_omega0()
        self.log_ratio = self.params.compute_log_ratio()
        self.epsilon = self.params.compute_epsilon()
    
    def compute_psi_field(self, x: np.ndarray, t: float) -> float:
        """
        Compute noetic field Ψ(x,t).
        
        Ψ(x,t) = Ψ₀ cos(ω₀t + c₀·k·x)
        
        Args:
            x: Spatial coordinates (3D vector or array)
            t: Time
            
        Returns:
            Noetic field value
        """
        if x.ndim == 1:
            # Single point
            phase = self.omega_0 * t + self.params.c0 * np.sum(x)
        else:
            # Field over grid
            phase = self.omega_0 * t + self.params.c0 * np.sum(x, axis=0)
        
        return self.psi_0 * np.cos(phase)
    
    def compute_psi_time_derivative(self, x: np.ndarray, t: float, order: int = 1) -> float:
        """
        Compute time derivative of Ψ.
        
        ∂Ψ/∂t = -Ψ₀ω₀ sin(ω₀t + c₀·k·x)
        ∂²Ψ/∂t² = -Ψ₀ω₀² cos(ω₀t + c₀·k·x) = -ω₀²Ψ
        
        Args:
            x: Spatial coordinates
            t: Time
            order: Derivative order (1 or 2)
            
        Returns:
            Time derivative of Ψ
        """
        if x.ndim == 1:
            phase = self.omega_0 * t + self.params.c0 * np.sum(x)
        else:
            phase = self.omega_0 * t + self.params.c0 * np.sum(x, axis=0)
        
        if order == 1:
            return -self.psi_0 * self.omega_0 * np.sin(phase)
        elif order == 2:
            return -self.psi_0 * self.omega_0**2 * np.cos(phase)
        else:
            raise ValueError(f"Derivative order {order} not supported")
    
    def compute_epsilon_field(self, x: np.ndarray) -> float:
        """
        Compute regularization field ε(x).
        
        For simplicity, we use a spatially varying regularization:
        ε(x) = ε₀(1 + β·sin(k·x))
        
        Args:
            x: Spatial coordinates
            
        Returns:
            Regularization field value
        """
        beta = 0.1  # Modulation amplitude
        k = np.array([1.0, 1.0, 1.0])  # Wave vector
        
        if x.ndim == 1:
            spatial_mod = beta * np.sin(np.dot(k, x))
        else:
            spatial_mod = beta * np.sin(np.sum(k[:, None, None, None] * x, axis=0))
        
        return self.epsilon * (1.0 + spatial_mod)
    
    def compute_spatial_derivatives(self, field: np.ndarray, 
                                   order: Tuple[int, int],
                                   grid_spacing: float = 1.0) -> np.ndarray:
        """
        Compute spatial derivatives using finite differences.
        
        Args:
            field: Field to differentiate (scalar or vector)
            order: Tuple (i, j) for ∂²/∂x_i∂x_j
            grid_spacing: Grid spacing for derivatives
            
        Returns:
            Second derivative field
        """
        i, j = order
        
        # First derivative along axis i
        df_dxi = np.gradient(field, grid_spacing, axis=i)
        
        # Second derivative along axis j
        d2f_dxidxj = np.gradient(df_dxi, grid_spacing, axis=j)
        
        return d2f_dxidxj
    
    def compute_ricci_tensor(self, x: np.ndarray, i: int, j: int,
                            grid_spacing: float = 1.0) -> np.ndarray:
        """
        Compute effective Ricci tensor component: R_ij ≈ ∂_i∂_j ε
        
        The fluid itself generates an effective geometry through the
        regularization field ε(x).
        
        Args:
            x: Spatial grid coordinates
            i: First index (0, 1, 2 for x, y, z)
            j: Second index (0, 1, 2 for x, y, z)
            grid_spacing: Grid spacing
            
        Returns:
            Ricci tensor component R_ij
        """
        # Compute epsilon field
        epsilon_field = self.compute_epsilon_field(x)
        
        # Compute second derivative
        R_ij = self.compute_spatial_derivatives(epsilon_field, (i, j), grid_spacing)
        
        return R_ij
    
    def compute_phi_tensor_component(self, x: np.ndarray, t: float,
                                    i: int, j: int,
                                    grid_spacing: float = 1.0) -> np.ndarray:
        """
        Compute Seeley-DeWitt tensor component Φ_ij(Ψ).
        
        Φ_ij(Ψ) = Ψ·∂²ε/∂x_i∂x_j 
                  + log(μ⁸/m_Ψ⁸)·∂²Ψ/∂x_i∂x_j 
                  + 2·∂²Ψ/∂t² (for i=j only, trace contribution)
        
        Args:
            x: Spatial grid coordinates
            t: Time
            i: First index (0, 1, 2)
            j: Second index (0, 1, 2)
            grid_spacing: Grid spacing
            
        Returns:
            Φ_ij component field
        """
        # Term 1: Ψ·∂²ε/∂x_i∂x_j (effective Ricci coupling)
        psi = self.compute_psi_field(x, t)
        R_ij = self.compute_ricci_tensor(x, i, j, grid_spacing)
        term1 = psi * R_ij
        
        # Term 2: log(μ⁸/m_Ψ⁸)·∂²Ψ/∂x_i∂x_j (logarithmic quantum correction)
        psi_field_full = self.compute_psi_field(x, t)
        d2_psi_spatial = self.compute_spatial_derivatives(psi_field_full, (i, j), grid_spacing)
        term2 = self.log_ratio * d2_psi_spatial
        
        # Term 3: 2·∂²Ψ/∂t² (temporal dynamics, appears as trace)
        # This is a scalar that contributes to diagonal terms
        d2_psi_dt2 = self.compute_psi_time_derivative(x, t, order=2)
        
        if i == j:
            # Diagonal terms include temporal contribution
            term3 = 2.0 * d2_psi_dt2
        else:
            # Off-diagonal terms don't include temporal part
            term3 = 0.0
        
        # Total Φ_ij
        phi_ij = term1 + term2 + term3
        
        return phi_ij
    
    def compute_phi_tensor_full(self, x: np.ndarray, t: float,
                               grid_spacing: float = 1.0) -> np.ndarray:
        """
        Compute full 3×3 Seeley-DeWitt tensor Φ_ij(Ψ) at all spatial points.
        
        Args:
            x: Spatial grid coordinates (3, Nx, Ny, Nz)
            t: Time
            grid_spacing: Grid spacing
            
        Returns:
            Full tensor (3, 3, Nx, Ny, Nz)
        """
        shape = x.shape[1:]  # Grid dimensions
        phi_tensor = np.zeros((3, 3, *shape))
        
        for i in range(3):
            for j in range(3):
                phi_tensor[i, j] = self.compute_phi_tensor_component(
                    x, t, i, j, grid_spacing
                )
        
        return phi_tensor
    
    def compute_extended_nse_coupling(self, u: np.ndarray, 
                                     phi_tensor: np.ndarray) -> np.ndarray:
        """
        Compute coupling term Φ_ij(Ψ)u_j for extended NSE.
        
        The extended Navier-Stokes equation:
        ∂_t u_i + u_j∇_j u_i = -∇_i p + ν∆u_i + Φ_ij(Ψ)u_j
        
        Args:
            u: Velocity field (3, Nx, Ny, Nz)
            phi_tensor: Seeley-DeWitt tensor (3, 3, Nx, Ny, Nz)
            
        Returns:
            Coupling term Φ_ij u_j (3, Nx, Ny, Nz)
        """
        coupling = np.zeros_like(u)
        
        for i in range(3):
            for j in range(3):
                # Contract tensor with velocity: Φ_ij u_j
                coupling[i] += phi_tensor[i, j] * u[j]
        
        return coupling
    
    def compute_extended_nse_rhs(self, u: np.ndarray,
                                 pressure_gradient: np.ndarray,
                                 viscosity: float,
                                 t: float,
                                 x: np.ndarray,
                                 grid_spacing: float = 1.0) -> np.ndarray:
        """
        Compute right-hand side of extended Navier-Stokes equations.
        
        RHS = -(u·∇)u - ∇p + ν∆u + Φ_ij(Ψ)u_j
        
        Args:
            u: Velocity field (3, Nx, Ny, Nz)
            pressure_gradient: Pressure gradient ∇p (3, Nx, Ny, Nz)
            viscosity: Kinematic viscosity ν
            t: Time
            x: Spatial grid coordinates (3, Nx, Ny, Nz)
            grid_spacing: Grid spacing
            
        Returns:
            RHS of extended NSE (3, Nx, Ny, Nz)
        """
        # Convection term: -(u·∇)u (simplified, compute properly in practice)
        convection = np.zeros_like(u)
        for i in range(3):
            for j in range(3):
                convection[i] += u[j] * np.gradient(u[i], grid_spacing, axis=j)
        convection = -convection
        
        # Diffusion term: ν∆u
        diffusion = np.zeros_like(u)
        for i in range(3):
            laplacian = (
                np.gradient(np.gradient(u[i], grid_spacing, axis=0), grid_spacing, axis=0) +
                np.gradient(np.gradient(u[i], grid_spacing, axis=1), grid_spacing, axis=1) +
                np.gradient(np.gradient(u[i], grid_spacing, axis=2), grid_spacing, axis=2)
            )
            diffusion[i] = viscosity * laplacian
        
        # Seeley-DeWitt coupling term: Φ_ij(Ψ)u_j
        phi_tensor = self.compute_phi_tensor_full(x, t, grid_spacing)
        sd_coupling = self.compute_extended_nse_coupling(u, phi_tensor)
        
        # Total RHS
        rhs = convection - pressure_gradient + diffusion + sd_coupling
        
        return rhs
    
    def analyze_energy_balance(self, u: np.ndarray,
                              phi_tensor: np.ndarray,
                              grid_spacing: float = 1.0) -> Dict:
        """
        Analyze energy contribution from Seeley-DeWitt coupling.
        
        Energy rate: dE/dt = ∫ u_i Φ_ij u_j dx
        
        Args:
            u: Velocity field (3, Nx, Ny, Nz)
            phi_tensor: Seeley-DeWitt tensor (3, 3, Nx, Ny, Nz)
            grid_spacing: Grid spacing
            
        Returns:
            Energy analysis dictionary
        """
        # Compute coupling term
        coupling = self.compute_extended_nse_coupling(u, phi_tensor)
        
        # Energy rate: u · (Φu)
        energy_rate_density = np.sum(u * coupling, axis=0)
        
        # Integrate over domain
        dV = grid_spacing**3
        total_energy_rate = np.sum(energy_rate_density) * dV
        
        # Check symmetry of Φ (should be symmetric for energy conservation)
        phi_symmetry_error = 0.0
        for i in range(3):
            for j in range(i+1, 3):
                error = np.max(np.abs(phi_tensor[i, j] - phi_tensor[j, i]))
                phi_symmetry_error = max(phi_symmetry_error, error)
        
        # Compute trace and determinant for tensor characterization
        phi_trace = np.sum([phi_tensor[i, i] for i in range(3)], axis=0)
        
        return {
            'energy_rate': total_energy_rate,
            'max_energy_rate_density': np.max(np.abs(energy_rate_density)),
            'avg_energy_rate_density': np.mean(energy_rate_density),
            'symmetry_error': phi_symmetry_error,
            'phi_trace_max': np.max(phi_trace),
            'phi_trace_min': np.min(phi_trace),
            'energy_sign': 'damping' if total_energy_rate < 0 else 'amplifying'
        }
    
    def validate_seeley_dewitt_tensor(self) -> Dict:
        """
        Validate Seeley-DeWitt tensor implementation.
        
        Returns:
            Validation results
        """
        # Create test grid
        N = 16
        L = 2 * np.pi
        x = np.linspace(0, L, N)
        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')
        grid = np.array([X, Y, Z])
        
        grid_spacing = L / (N - 1)
        t = 0.0
        
        # Compute tensor
        phi_tensor = self.compute_phi_tensor_full(grid, t, grid_spacing)
        
        # Check symmetry
        symmetry_errors = []
        for i in range(3):
            for j in range(i+1, 3):
                error = np.max(np.abs(phi_tensor[i, j] - phi_tensor[j, i]))
                symmetry_errors.append(error)
        
        max_symmetry_error = max(symmetry_errors) if symmetry_errors else 0.0
        is_symmetric = max_symmetry_error < 1e-10
        
        # Check finite values
        all_finite = np.all(np.isfinite(phi_tensor))
        
        # Check spatial structure
        phi_range = np.max(phi_tensor) - np.min(phi_tensor)
        has_structure = phi_range > 1e-10
        
        # Compute representative values
        phi_mean = np.mean(phi_tensor)
        phi_std = np.std(phi_tensor)
        
        return {
            'tensor_shape': phi_tensor.shape,
            'all_finite': all_finite,
            'is_symmetric': is_symmetric,
            'max_symmetry_error': max_symmetry_error,
            'has_spatial_structure': has_structure,
            'phi_mean': phi_mean,
            'phi_std': phi_std,
            'phi_max': np.max(phi_tensor),
            'phi_min': np.min(phi_tensor),
            'validation_passed': all_finite and is_symmetric and has_structure
        }


def demonstrate_seeley_dewitt_tensor():
    """Demonstrate Seeley-DeWitt tensor computation."""
    print("="*70)
    print("SEELEY-DEWITT TENSOR Φ_ij(Ψ)")
    print("Quantum-Geometric Coupling for Extended Navier-Stokes")
    print("="*70)
    print()
    
    # Initialize tensor computation
    sdt = SeeleyDeWittTensor()
    
    print(f"Seeley-DeWitt Parameters:")
    print(f"  Energy scale μ: {sdt.params.mu}")
    print(f"  Noetic mass m_Ψ: {sdt.params.m_psi}")
    print(f"  Log ratio log(μ⁸/m_Ψ⁸): {sdt.log_ratio:.6f}")
    print(f"  Universal frequency f₀: {sdt.params.f0} Hz")
    print(f"  Noetic amplitude Ψ₀: {sdt.psi_0}")
    print(f"  Regularization ε: {sdt.epsilon:.6e}")
    print()
    
    # Validate tensor
    print("Validating Seeley-DeWitt tensor...")
    results = sdt.validate_seeley_dewitt_tensor()
    
    print("\nValidation Results:")
    print("-"*70)
    for key, value in results.items():
        if isinstance(value, bool):
            status = "✓" if value else "✗"
            print(f"  {status} {key}: {value}")
        elif isinstance(value, tuple):
            print(f"  • {key}: {value}")
        elif isinstance(value, float):
            print(f"  • {key}: {value:.6e}")
        else:
            print(f"  • {key}: {value}")
    
    # Demonstrate energy analysis
    print("\n" + "-"*70)
    print("Energy Balance Analysis")
    print("-"*70)
    
    N = 16
    L = 2 * np.pi
    x = np.linspace(0, L, N)
    X, Y, Z = np.meshgrid(x, x, x, indexing='ij')
    grid = np.array([X, Y, Z])
    grid_spacing = L / (N - 1)
    
    # Create test velocity field
    u = np.random.randn(3, N, N, N) * 0.1
    
    # Compute tensor
    phi_tensor = sdt.compute_phi_tensor_full(grid, 0.0, grid_spacing)
    
    # Analyze energy
    energy_analysis = sdt.analyze_energy_balance(u, phi_tensor, grid_spacing)
    
    print()
    for key, value in energy_analysis.items():
        if isinstance(value, float):
            print(f"  • {key}: {value:.6e}")
        else:
            print(f"  • {key}: {value}")
    
    print("\n" + "="*70)
    if results['validation_passed']:
        print("✓ SEELEY-DEWITT TENSOR VALIDATED")
        print("  Extended NSE with quantum-geometric coupling ready")
    else:
        print("✗ VALIDATION INCOMPLETE")
    print("="*70)


if __name__ == "__main__":
    demonstrate_seeley_dewitt_tensor()
