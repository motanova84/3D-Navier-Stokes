#!/usr/bin/env python3
"""
M√≥dulo de visualizaci√≥n de Œ∂'(1/2) - Proyecci√≥n de la derivada de Riemann sobre modos del fluido.

Visualiza c√≥mo la derivada espectral de la funci√≥n zeta de Riemann afecta la disociaci√≥n
dy√°dica y la energ√≠a modal del fluido, comparando escenarios con y sin Œ∂'(1/2).
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Optional
import warnings
warnings.filterwarnings('ignore')

class RiemannZetaVisualizer:
    """
    Visualizador de efectos de Œ∂'(1/2) sobre modos del fluido.
    
    Implementa:
    - C√°lculo aproximado de Œ∂'(1/2)
    - Proyecci√≥n sobre modos dy√°dicos
    - Comparaci√≥n de escenarios sin/con Œ∂'(1/2)/con f‚ÇÄ
    """
    
    def __init__(self, n_modes: int = 50, f0: float = 141.7001):
        """
        Inicializa el visualizador.
        
        Args:
            n_modes: N√∫mero de modos dy√°dicos
            f0: Frecuencia fundamental de coherencia (Hz)
        """
        self.n_modes = n_modes
        self.f0 = f0
        self.omega0 = 2 * np.pi * f0
        
        # Valor aproximado de Œ∂'(1/2) (derivada en l√≠nea cr√≠tica)
        # Œ∂'(1/2) ‚âà -3.92... (valor num√©rico conocido)
        self.zeta_prime_half = -3.92264867
        
    def dyadic_modes(self) -> np.ndarray:
        """
        Genera n√∫meros de onda dy√°dicos k_j = 2^j.
        
        Returns:
            k: Array de n√∫meros de onda dy√°dicos
        """
        j = np.arange(1, self.n_modes + 1)
        k = 2.0 ** j
        return k
    
    def energy_spectrum_baseline(self, k: np.ndarray) -> np.ndarray:
        """
        Espectro de energ√≠a base (sin Œ∂'(1/2)).
        
        E(k) ~ k^(-5/3) (cascada de Kolmogorov)
        
        Args:
            k: N√∫meros de onda
            
        Returns:
            E: Energ√≠a espectral
        """
        E = k ** (-5/3) * np.exp(-k / 1e5)
        return E
    
    def zeta_modulation(self, k: np.ndarray) -> np.ndarray:
        """
        Factor de modulaci√≥n por Œ∂'(1/2).
        
        M(k) = 1 + Œµ¬∑Œ∂'(1/2)¬∑k^(-1/2)
        
        Args:
            k: N√∫meros de onda
            
        Returns:
            M: Factor de modulaci√≥n
        """
        epsilon = 0.1  # Par√°metro de acoplamiento
        M = 1 + epsilon * self.zeta_prime_half * k ** (-0.5)
        return M
    
    def frequency_modulation(self, k: np.ndarray, t: float = 0) -> np.ndarray:
        """
        Factor de modulaci√≥n adicional por f‚ÇÄ.
        
        F(k,t) = 1 + Œ±¬∑cos(œâ‚ÇÄ¬∑t)¬∑exp(-k/k‚ÇÄ)
        
        Args:
            k: N√∫meros de onda
            t: Tiempo
            
        Returns:
            F: Factor de modulaci√≥n por frecuencia
        """
        alpha = 0.2
        k0 = 100.0
        F = 1 + alpha * np.cos(self.omega0 * t) * np.exp(-k / k0)
        return F
    
    def energy_spectrum_with_zeta(self, k: np.ndarray) -> np.ndarray:
        """
        Espectro de energ√≠a con Œ∂'(1/2).
        
        Args:
            k: N√∫meros de onda
            
        Returns:
            E: Energ√≠a espectral modulada
        """
        E_base = self.energy_spectrum_baseline(k)
        M_zeta = self.zeta_modulation(k)
        E = E_base * M_zeta
        return E
    
    def energy_spectrum_with_zeta_and_f0(self, k: np.ndarray, t: float = 0) -> np.ndarray:
        """
        Espectro de energ√≠a con Œ∂'(1/2) y f‚ÇÄ.
        
        Args:
            k: N√∫meros de onda
            t: Tiempo
            
        Returns:
            E: Energ√≠a espectral con modulaci√≥n completa
        """
        E_base = self.energy_spectrum_baseline(k)
        M_zeta = self.zeta_modulation(k)
        F_freq = self.frequency_modulation(k, t)
        E = E_base * M_zeta * F_freq
        return E
    
    def dyadic_dissociation_rate(self, k: np.ndarray, scenario: str = 'baseline') -> np.ndarray:
        """
        Tasa de disociaci√≥n dy√°dica.
        
        Œì(k) = -dE/dk (tasa de transferencia energ√©tica)
        
        Args:
            k: N√∫meros de onda
            scenario: 'baseline', 'zeta', 'zeta_f0'
            
        Returns:
            gamma: Tasa de disociaci√≥n
        """
        dk = k[1] - k[0] if len(k) > 1 else 1.0
        
        if scenario == 'baseline':
            E = self.energy_spectrum_baseline(k)
        elif scenario == 'zeta':
            E = self.energy_spectrum_with_zeta(k)
        elif scenario == 'zeta_f0':
            E = self.energy_spectrum_with_zeta_and_f0(k, t=0)
        
        # Derivada num√©rica
        gamma = -np.gradient(E, dk)
        
        return gamma
    
    def visualize_comparison(self, t: float = 0, save_path: Optional[str] = None) -> None:
        """
        Visualiza comparaci√≥n de los tres escenarios.
        
        Args:
            t: Tiempo (relevante para escenario con f‚ÇÄ)
            save_path: Ruta para guardar la figura
        """
        # Generar modos dy√°dicos
        k = self.dyadic_modes()
        
        # Calcular espectros
        E_baseline = self.energy_spectrum_baseline(k)
        E_zeta = self.energy_spectrum_with_zeta(k)
        E_zeta_f0 = self.energy_spectrum_with_zeta_and_f0(k, t)
        
        # Calcular tasas de disociaci√≥n
        gamma_baseline = self.dyadic_dissociation_rate(k, 'baseline')
        gamma_zeta = self.dyadic_dissociation_rate(k, 'zeta')
        gamma_zeta_f0 = self.dyadic_dissociation_rate(k, 'zeta_f0')
        
        # Visualizaci√≥n
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        
        # Panel 1: Espectros de energ√≠a
        ax1.loglog(k, E_baseline, 'o-', label='Sin Œ∂\'(1/2)', linewidth=2, markersize=4)
        ax1.loglog(k, E_zeta, 's-', label='Con Œ∂\'(1/2)', linewidth=2, markersize=4)
        ax1.loglog(k, E_zeta_f0, '^-', label=f'Con Œ∂\'(1/2) + f‚ÇÄ', linewidth=2, markersize=4)
        ax1.set_xlabel('N√∫mero de onda k', fontsize=12)
        ax1.set_ylabel('Energ√≠a E(k)', fontsize=12)
        ax1.set_title('Espectro de Energ√≠a Modal', fontsize=14)
        ax1.legend(fontsize=10)
        ax1.grid(True, alpha=0.3, which='both')
        
        # Panel 2: Diferencia relativa
        diff_zeta = (E_zeta - E_baseline) / (E_baseline + 1e-10) * 100
        diff_zeta_f0 = (E_zeta_f0 - E_baseline) / (E_baseline + 1e-10) * 100
        
        ax2.semilogx(k, diff_zeta, 's-', label='Œ∂\'(1/2) vs baseline', linewidth=2, markersize=4)
        ax2.semilogx(k, diff_zeta_f0, '^-', label='Œ∂\'(1/2)+f‚ÇÄ vs baseline', linewidth=2, markersize=4)
        ax2.axhline(y=0, color='k', linestyle='--', alpha=0.3)
        ax2.set_xlabel('N√∫mero de onda k', fontsize=12)
        ax2.set_ylabel('Diferencia relativa (%)', fontsize=12)
        ax2.set_title('Efecto de Œ∂\'(1/2) sobre Energ√≠a Modal', fontsize=14)
        ax2.legend(fontsize=10)
        ax2.grid(True, alpha=0.3)
        
        # Panel 3: Tasa de disociaci√≥n dy√°dica
        ax3.semilogx(k, gamma_baseline, 'o-', label='Sin Œ∂\'(1/2)', linewidth=2, markersize=4)
        ax3.semilogx(k, gamma_zeta, 's-', label='Con Œ∂\'(1/2)', linewidth=2, markersize=4)
        ax3.semilogx(k, gamma_zeta_f0, '^-', label=f'Con Œ∂\'(1/2) + f‚ÇÄ', linewidth=2, markersize=4)
        ax3.axhline(y=0, color='k', linestyle='--', alpha=0.3)
        ax3.set_xlabel('N√∫mero de onda k', fontsize=12)
        ax3.set_ylabel('Œì(k) = -dE/dk', fontsize=12)
        ax3.set_title('Tasa de Disociaci√≥n Dy√°dica', fontsize=14)
        ax3.legend(fontsize=10)
        ax3.grid(True, alpha=0.3)
        
        # Panel 4: Factor de modulaci√≥n
        M_zeta = self.zeta_modulation(k)
        F_freq = self.frequency_modulation(k, t)
        M_combined = M_zeta * F_freq
        
        ax4.semilogx(k, M_zeta, 's-', label='M_Œ∂ (modulaci√≥n por Œ∂\'(1/2))', linewidth=2, markersize=4)
        ax4.semilogx(k, F_freq, '^-', label='F (modulaci√≥n por f‚ÇÄ)', linewidth=2, markersize=4)
        ax4.semilogx(k, M_combined, 'o-', label='M_Œ∂ √ó F (combinado)', linewidth=2, markersize=4)
        ax4.axhline(y=1, color='k', linestyle='--', alpha=0.3)
        ax4.set_xlabel('N√∫mero de onda k', fontsize=12)
        ax4.set_ylabel('Factor de modulaci√≥n', fontsize=12)
        ax4.set_title(f'Factores de Modulaci√≥n (t={t:.2f}s)', fontsize=14)
        ax4.legend(fontsize=10)
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"‚úÖ Visualizaci√≥n guardada en: {save_path}")
        
        plt.show()
        
        # Estad√≠sticas
        print(f"\nüìä Estad√≠sticas Comparativas:")
        print(f"   Œ∂'(1/2) = {self.zeta_prime_half:.8f}")
        print(f"   f‚ÇÄ = {self.f0:.4f} Hz")
        print(f"\n   Energ√≠a total (sin Œ∂'(1/2)):      {E_baseline.sum():.6e}")
        print(f"   Energ√≠a total (con Œ∂'(1/2)):      {E_zeta.sum():.6e}")
        print(f"   Energ√≠a total (con Œ∂'(1/2) + f‚ÇÄ): {E_zeta_f0.sum():.6e}")
        print(f"\n   Cambio por Œ∂'(1/2):      {(E_zeta.sum() - E_baseline.sum()) / E_baseline.sum() * 100:.2f}%")
        print(f"   Cambio por Œ∂'(1/2) + f‚ÇÄ: {(E_zeta_f0.sum() - E_baseline.sum()) / E_baseline.sum() * 100:.2f}%")


def main():
    """Funci√≥n principal de demostraci√≥n."""
    print("=" * 70)
    print("üìä M√ìDULO Œ∂'(1/2) - VISUALIZACI√ìN RIEMANN-NAVIER-STOKES")
    print("=" * 70)
    print(f"üî¢ Derivada de Riemann: Œ∂'(1/2) ‚âà -3.92264867")
    print(f"üéµ Frecuencia fundamental: f‚ÇÄ = 141.7001 Hz")
    print(f"üåÄ Modos dy√°dicos: k_j = 2^j")
    print("=" * 70)
    print()
    
    # Crear visualizador
    visualizer = RiemannZetaVisualizer(n_modes=30, f0=141.7001)
    
    # Ejemplo 1: Comparaci√≥n en t=0
    print("üìä Ejemplo 1: Comparaci√≥n en t=0")
    visualizer.visualize_comparison(t=0)
    
    # Ejemplo 2: Comparaci√≥n en t=œÄ/(2œâ‚ÇÄ)
    print("\nüìä Ejemplo 2: Comparaci√≥n en fase œÄ/2")
    visualizer.visualize_comparison(t=np.pi / (2 * visualizer.omega0))
    
    # Ejemplo 3: Comparaci√≥n en t=œÄ/œâ‚ÇÄ
    print("\nüìä Ejemplo 3: Comparaci√≥n en fase œÄ")
    visualizer.visualize_comparison(t=np.pi / visualizer.omega0)
    
    print("\n" + "=" * 70)
    print("‚úÖ An√°lisis completado")
    print("üî∑ Conclusi√≥n: Œ∂'(1/2) modula la disociaci√≥n dy√°dica")
    print("üî∑ Efecto amplificado: Acoplamiento con f‚ÇÄ = 141.7001 Hz")
    print("=" * 70)


if __name__ == "__main__":
    main()
